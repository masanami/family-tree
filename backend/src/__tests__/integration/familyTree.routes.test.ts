import request from 'supertest';
import { App } from '../../app';
import { Server } from 'http';
import { PrismaClient } from '@prisma/client';

describe('Family Tree Routes Integration', () => {
  let app: App;
  let server: Server;
  let prisma: PrismaClient;
  let authToken: string;
  let userId: string;

  beforeAll(async () => {
    app = new App();
    server = app.getServer();
    prisma = new PrismaClient();
    
    // Clean up database
    await prisma.familyTree.deleteMany();
    await prisma.user.deleteMany();
    
    // Create test user and get auth token
    const user = await prisma.user.create({
      data: {
        email: 'test@example.com',
        password: 'hashedpassword', // In real app, this would be hashed
        name: 'Test User',
      },
    });
    userId = user.id;
    
    // Mock auth token (in real app, this would be generated by auth service)
    authToken = 'Bearer mock-jwt-token';
  });

  afterAll(async () => {
    await prisma.familyTree.deleteMany();
    await prisma.user.deleteMany();
    await prisma.$disconnect();
    if (server) {
      server.close();
    }
  });

  describe('POST /api/v1/family-trees', () => {
    it('should create a new family tree', async () => {
      const newFamilyTree = {
        name: '田中家系図',
        description: 'テスト用の家系図です',
        isPublic: false,
      };

      const response = await request(server)
        .post('/api/v1/family-trees')
        .set('Authorization', authToken)
        .send(newFamilyTree)
        .expect(201);

      expect(response.body).toMatchObject({
        id: expect.any(String),
        name: newFamilyTree.name,
        description: newFamilyTree.description,
        isPublic: newFamilyTree.isPublic,
        ownerId: userId,
        createdAt: expect.any(String),
        updatedAt: expect.any(String),
      });
    });

    it('should validate required fields', async () => {
      const invalidFamilyTree = {
        description: 'Missing name field',
        isPublic: false,
      };

      const response = await request(server)
        .post('/api/v1/family-trees')
        .set('Authorization', authToken)
        .send(invalidFamilyTree)
        .expect(400);

      expect(response.body.error).toHaveProperty('message');
      expect(response.body.error.errors).toHaveProperty('name');
    });

    it('should require authentication', async () => {
      const newFamilyTree = {
        name: 'Unauthorized Family Tree',
        description: 'Should fail',
        isPublic: false,
      };

      await request(server)
        .post('/api/v1/family-trees')
        .send(newFamilyTree)
        .expect(401);
    });
  });

  describe('GET /api/v1/family-trees', () => {
    let familyTreeId1: string;
    let familyTreeId2: string;

    beforeEach(async () => {
      // Create test family trees
      const ft1 = await prisma.familyTree.create({
        data: {
          name: 'Public Family Tree',
          description: 'A public tree',
          isPublic: true,
          ownerId: userId,
        },
      });
      familyTreeId1 = ft1.id;

      const ft2 = await prisma.familyTree.create({
        data: {
          name: 'Private Family Tree',
          description: 'A private tree',
          isPublic: false,
          ownerId: userId,
        },
      });
      familyTreeId2 = ft2.id;
    });

    afterEach(async () => {
      await prisma.familyTree.deleteMany();
    });

    it('should list all family trees for authenticated user', async () => {
      const response = await request(server)
        .get('/api/v1/family-trees')
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body.trees).toHaveLength(2);
      expect(response.body).toHaveProperty('total', 2);
      expect(response.body).toHaveProperty('page', 1);
      expect(response.body).toHaveProperty('hasMore', false);
    });

    it('should support pagination', async () => {
      // Create more family trees for pagination test
      for (let i = 0; i < 15; i++) {
        await prisma.familyTree.create({
          data: {
            name: `Family Tree ${i}`,
            description: `Description ${i}`,
            isPublic: false,
            ownerId: userId,
          },
        });
      }

      const response = await request(server)
        .get('/api/v1/family-trees?page=2&limit=10')
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body.trees).toHaveLength(7); // 2 + 15 = 17 total, page 2 with limit 10
      expect(response.body.page).toBe(2);
      expect(response.body.hasMore).toBe(false);
    });

    it('should filter by public status', async () => {
      const response = await request(server)
        .get('/api/v1/family-trees?isPublic=true')
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body.trees).toHaveLength(1);
      expect(response.body.trees[0].name).toBe('Public Family Tree');
    });
  });

  describe('GET /api/v1/family-trees/:id', () => {
    let familyTreeId: string;

    beforeEach(async () => {
      const ft = await prisma.familyTree.create({
        data: {
          name: 'Test Family Tree',
          description: 'For GET by ID test',
          isPublic: false,
          ownerId: userId,
        },
      });
      familyTreeId = ft.id;
    });

    afterEach(async () => {
      await prisma.familyTree.deleteMany();
    });

    it('should get a family tree by ID', async () => {
      const response = await request(server)
        .get(`/api/v1/family-trees/${familyTreeId}`)
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body).toMatchObject({
        id: familyTreeId,
        name: 'Test Family Tree',
        description: 'For GET by ID test',
        isPublic: false,
        ownerId: userId,
      });
    });

    it('should return 404 for non-existent family tree', async () => {
      await request(server)
        .get('/api/v1/family-trees/non-existent-id')
        .set('Authorization', authToken)
        .expect(404);
    });

    it('should include member count if requested', async () => {
      // Add some persons to the family tree
      await prisma.person.createMany({
        data: [
          { familyTreeId, firstName: 'John', lastName: 'Doe', gender: 'male' },
          { familyTreeId, firstName: 'Jane', lastName: 'Doe', gender: 'female' },
        ],
      });

      const response = await request(server)
        .get(`/api/v1/family-trees/${familyTreeId}?includeCounts=true`)
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body.membersCount).toBe(2);
    });
  });

  describe('PUT /api/v1/family-trees/:id', () => {
    let familyTreeId: string;

    beforeEach(async () => {
      const ft = await prisma.familyTree.create({
        data: {
          name: 'Original Name',
          description: 'Original Description',
          isPublic: false,
          ownerId: userId,
        },
      });
      familyTreeId = ft.id;
    });

    afterEach(async () => {
      await prisma.familyTree.deleteMany();
    });

    it('should update a family tree', async () => {
      const updates = {
        name: 'Updated Name',
        description: 'Updated Description',
        isPublic: true,
      };

      const response = await request(server)
        .put(`/api/v1/family-trees/${familyTreeId}`)
        .set('Authorization', authToken)
        .send(updates)
        .expect(200);

      expect(response.body).toMatchObject({
        id: familyTreeId,
        ...updates,
        ownerId: userId,
      });
    });

    it('should allow partial updates', async () => {
      const partialUpdate = {
        name: 'Only Name Updated',
      };

      const response = await request(server)
        .put(`/api/v1/family-trees/${familyTreeId}`)
        .set('Authorization', authToken)
        .send(partialUpdate)
        .expect(200);

      expect(response.body.name).toBe('Only Name Updated');
      expect(response.body.description).toBe('Original Description');
      expect(response.body.isPublic).toBe(false);
    });

    it('should prevent non-owners from updating', async () => {
      // Create another user
      const otherUser = await prisma.user.create({
        data: {
          email: 'other@example.com',
          password: 'hashedpassword',
          name: 'Other User',
        },
      });

      // Create family tree owned by other user
      const otherFt = await prisma.familyTree.create({
        data: {
          name: 'Other User Tree',
          description: 'Not mine',
          isPublic: false,
          ownerId: otherUser.id,
        },
      });

      await request(server)
        .put(`/api/v1/family-trees/${otherFt.id}`)
        .set('Authorization', authToken)
        .send({ name: 'Trying to update' })
        .expect(403);

      await prisma.familyTree.delete({ where: { id: otherFt.id } });
      await prisma.user.delete({ where: { id: otherUser.id } });
    });
  });

  describe('DELETE /api/v1/family-trees/:id', () => {
    let familyTreeId: string;

    beforeEach(async () => {
      const ft = await prisma.familyTree.create({
        data: {
          name: 'To Be Deleted',
          description: 'Will be removed',
          isPublic: false,
          ownerId: userId,
        },
      });
      familyTreeId = ft.id;
    });

    it('should delete a family tree', async () => {
      await request(server)
        .delete(`/api/v1/family-trees/${familyTreeId}`)
        .set('Authorization', authToken)
        .expect(204);

      // Verify deletion
      const deletedFt = await prisma.familyTree.findUnique({
        where: { id: familyTreeId },
      });
      expect(deletedFt).toBeNull();
    });

    it('should cascade delete related data', async () => {
      // Add persons and relationships
      const person1 = await prisma.person.create({
        data: {
          familyTreeId,
          firstName: 'John',
          lastName: 'Doe',
          gender: 'male',
        },
      });

      const person2 = await prisma.person.create({
        data: {
          familyTreeId,
          firstName: 'Jane',
          lastName: 'Doe',
          gender: 'female',
        },
      });

      await prisma.relationship.create({
        data: {
          familyTreeId,
          person1Id: person1.id,
          person2Id: person2.id,
          relationshipType: 'spouse',
        },
      });

      const response = await request(server)
        .delete(`/api/v1/family-trees/${familyTreeId}`)
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body).toHaveProperty('deletedCount');
      expect(response.body.deletedCount).toMatchObject({
        familyTree: 1,
        persons: 2,
        relationships: 1,
      });

      // Verify cascade deletion
      const persons = await prisma.person.findMany({
        where: { familyTreeId },
      });
      expect(persons).toHaveLength(0);
    });

    it('should prevent non-owners from deleting', async () => {
      // Create another user and their family tree
      const otherUser = await prisma.user.create({
        data: {
          email: 'another@example.com',
          password: 'hashedpassword',
          name: 'Another User',
        },
      });

      const otherFt = await prisma.familyTree.create({
        data: {
          name: 'Another Tree',
          description: 'Not deletable by test user',
          isPublic: false,
          ownerId: otherUser.id,
        },
      });

      await request(server)
        .delete(`/api/v1/family-trees/${otherFt.id}`)
        .set('Authorization', authToken)
        .expect(403);

      // Cleanup
      await prisma.familyTree.delete({ where: { id: otherFt.id } });
      await prisma.user.delete({ where: { id: otherUser.id } });
    });
  });

  describe('Family Tree Sharing', () => {
    let familyTreeId: string;
    let sharedUserId: string;

    beforeEach(async () => {
      // Create a family tree
      const ft = await prisma.familyTree.create({
        data: {
          name: 'Shared Family Tree',
          description: 'To be shared',
          isPublic: false,
          ownerId: userId,
        },
      });
      familyTreeId = ft.id;

      // Create another user to share with
      const sharedUser = await prisma.user.create({
        data: {
          email: 'shared@example.com',
          password: 'hashedpassword',
          name: 'Shared User',
        },
      });
      sharedUserId = sharedUser.id;
    });

    afterEach(async () => {
      await prisma.familyTreeShare.deleteMany();
      await prisma.familyTree.deleteMany();
      await prisma.user.deleteMany({ where: { id: sharedUserId } });
    });

    it('should share a family tree with another user', async () => {
      const shareRequest = {
        userId: sharedUserId,
        permission: 'view',
      };

      const response = await request(server)
        .post(`/api/v1/family-trees/${familyTreeId}/share`)
        .set('Authorization', authToken)
        .send(shareRequest)
        .expect(201);

      expect(response.body).toMatchObject({
        familyTreeId,
        userId: sharedUserId,
        permission: 'view',
      });
    });

    it('should list users a family tree is shared with', async () => {
      // Share the family tree first
      await prisma.familyTreeShare.create({
        data: {
          familyTreeId,
          userId: sharedUserId,
          permission: 'view',
        },
      });

      const response = await request(server)
        .get(`/api/v1/family-trees/${familyTreeId}/shares`)
        .set('Authorization', authToken)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0]).toMatchObject({
        userId: sharedUserId,
        permission: 'view',
        userName: 'Shared User',
      });
    });
  });
});