# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä»•æ§˜æ›¸

## âš ï¸ é©ç”¨ç¯„å›²ãƒ»å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼

### **ğŸ¯ å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **
æœ¬ä»•æ§˜æ›¸ã¯ä»¥ä¸‹ã®ã‚ˆã†ãª**å¤§è¦æ¨¡ãƒ»ä¼æ¥­ãƒ¬ãƒ™ãƒ«**ã®AIã‚·ã‚¹ãƒ†ãƒ ã‚’å¯¾è±¡ã¨ã—ã¦ã„ã¾ã™ï¼š

- **è¤‡æ•°ã®AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒ24/7ã§å”èª¿å‹•ä½œ**ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ 
- **æ•°åã€œæ•°ç™¾ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**ãŒåŒæ™‚ç¨¼åƒã™ã‚‹ç’°å¢ƒ
- **ä¼æ¥­ã®CI/CDã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã®å®Œå…¨è‡ªå‹•åŒ–**ã‚·ã‚¹ãƒ†ãƒ 
- **ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ**ã®AIã‚µãƒ¼ãƒ“ã‚¹åŸºç›¤

### **âŒ å€‹äººåˆ©ç”¨ãƒ»å°è¦æ¨¡ã‚¹ã‚¿ãƒ¼ãƒˆã«ã¯ä¸é©ç”¨**
ä»¥ä¸‹ã®ã‚ˆã†ãªå€‹äººã‚„å°è¦æ¨¡ãƒãƒ¼ãƒ ã®é–‹ç™ºç’°å¢ƒã§ã¯ã€**ã“ã®ä»•æ§˜ã¯å®Œå…¨ã«ã‚ªãƒ¼ãƒãƒ¼ã‚¹ãƒšãƒƒã‚¯**ã§ã™ï¼š

```yaml
å€‹äººãƒ»å°è¦æ¨¡ãƒãƒ¼ãƒ ã®ä¸€èˆ¬çš„ãªåˆ©ç”¨ã‚±ãƒ¼ã‚¹:
  claude_code: "ã‚³ãƒ¼ãƒ‰ç·¨é›† + GitHubé€£æº"
  claude_desktop: "æƒ…å ±æ¤œç´¢ + æ–‡æ›¸ä½œæˆ"  
  # â†‘ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ã¯ç™ºç”Ÿã—ãªã„
  
å°è¦æ¨¡ã‚¹ã‚¿ãƒ¼ãƒˆã§ã®æ¨å¥¨ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
  - 06_multi_agent_operational_workflow.md ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹é€šä¿¡ã§ååˆ†
  - 04_tool_integration_specs.md ã®MCPçµ±åˆã§åŠ¹ç‡åŒ–
  - ACPã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰ã¯ä¸è¦ï¼ˆã‚ªãƒ¼ãƒãƒ¼ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ï¼‰
  - ã‚µãƒ¼ãƒãƒ¼ã‚¤ãƒ³ãƒ•ãƒ©ã‚‚ä¸è¦
```

### **ğŸ“ˆ æ®µéšçš„æ‹¡å¼µæ™‚ã®æ´»ç”¨**
```yaml
é©ç”¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°:
  Phase1ï¼ˆ1-5ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰: 06ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹é€šä¿¡
  Phase2ï¼ˆ5-10ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰: éƒ¨åˆ†çš„ACPæ©Ÿèƒ½æ¤œè¨
  Phase3ï¼ˆ10+ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰: æœ¬ä»•æ§˜ã®æœ¬æ ¼æ¡ç”¨æ¤œè¨
  
ç§»è¡Œåˆ¤æ–­æŒ‡æ¨™:
  - ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ•° > 10å€‹
  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å”èª¿ã®å¿…è¦æ€§
  - ä¼æ¥­ãƒ¬ãƒ™ãƒ«ã®é‹ç”¨è¦ä»¶
  - ã‚¤ãƒ³ãƒ•ãƒ©æŠ•è³‡ã®æ­£å½“åŒ–
```

### **ğŸ¢ ä¼æ¥­ã§ã®å®Ÿè£…ä¾‹**
```yaml
æƒ³å®šã•ã‚Œã‚‹ä¼æ¥­ã‚·ã‚¹ãƒ†ãƒ :
  é–‹ç™ºãƒãƒ¼ãƒ è¦æ¨¡: 50-200äºº
  ç¨¼åƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ•°: 100-500å€‹
  å‡¦ç†ã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ•°: 10-50å€‹åŒæ™‚
  å¿…è¦ã‚¤ãƒ³ãƒ•ãƒ©: Redis, PostgreSQL, Kubernetesç­‰
  å¹´é–“é–‹ç™ºã‚³ã‚¹ãƒˆ: æ•°åƒä¸‡å††è¦æ¨¡
```

### **ğŸ“š æœ¬ä»•æ§˜æ›¸ã®å­¦ç¿’ä¾¡å€¤**
å°è¦æ¨¡ã§ã¯å®Ÿè£…ä¸è¦ã§ã™ãŒã€ä»¥ä¸‹ã®å­¦ç¿’ä¾¡å€¤ãŒã‚ã‚Šã¾ã™ï¼š
- **å¤§è¦æ¨¡AIã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã®ç†è§£**
- **åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å‚è€ƒ**
- **å°†æ¥çš„ãªä¼æ¥­ã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºã¸ã®æº–å‚™**

---

## ğŸ’¬ æ¦‚è¦

ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ã€ç«¶åˆè§£æ±ºã®ãŸã‚ã®åŒ…æ‹¬çš„ãªä»•æ§˜ã‚’å®šç¾©ã—ã¾ã™ã€‚
Agent Communication Protocol (ACP) ã‚’åŸºç›¤ã¨ã—ã€åŠ¹ç‡çš„ã§ä¿¡é ¼æ€§ã®é«˜ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå”èª¿ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

**âš ï¸ æ³¨æ„**: å°è¦æ¨¡ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆ1-5ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰ã§ã¯ã€`06_multi_agent_operational_workflow.md`ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ ã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚

---

## ğŸ”„ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### é€šä¿¡ãƒ¢ãƒ‡ãƒ«

#### ğŸŒ åˆ†æ•£å‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PM Agent    â”‚â—„â”€â”€â–ºâ”‚ Message Bus â”‚â—„â”€â”€â–ºâ”‚Engineer     â”‚
â”‚             â”‚    â”‚             â”‚    â”‚Agent        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–²                   â–²                   â–²
       â”‚                   â”‚                   â”‚
       â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚QA Agent     â”‚â—„â”€â”€â–ºâ”‚ ACP Router  â”‚â—„â”€â”€â–ºâ”‚Frontend     â”‚
â”‚             â”‚    â”‚             â”‚    â”‚Agent        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–²                   â–²                   â–²
       â”‚                   â”‚                   â”‚
       â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Tech Writer  â”‚â—„â”€â”€â–ºâ”‚ Context DB  â”‚â—„â”€â”€â–ºâ”‚Backend      â”‚
â”‚Agent        â”‚    â”‚             â”‚    â”‚Agent        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“¨ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ä»•æ§˜

##### **æ¨™æº–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼**
```json
{
  "header": {
    "protocol_version": "2.0",
    "message_id": "msg-{uuid}",
    "timestamp": "2024-01-15T10:30:00.000Z",
    "ttl": 3600,
    "compression": "gzip",
    "encryption": "AES-256"
  },
  "routing": {
    "sender": {
      "agent_id": "pm-agent-001",
      "agent_type": "ProductManager",
      "framework": "langchain",
      "version": "1.2.0"
    },
    "recipient": {
      "agent_id": "engineer-agent-001",
      "agent_type": "SeniorEngineer", 
      "framework": "autogen",
      "version": "0.9.3"
    },
    "reply_to": "pm-agent-001",
    "correlation_id": "task-workflow-456"
  },
  "message": {
    "type": "task_assignment",
    "priority": "high",
    "requires_ack": true,
    "content": {
      "task_id": "TASK-123",
      "description": "Implement user authentication API",
      "requirements": ["OAuth2", "JWT", "Rate limiting"],
      "deadline": "2024-01-20T17:00:00Z",
      "dependencies": ["schema_migration_complete"],
      "acceptance_criteria": [
        "API returns 401 for invalid tokens",
        "Rate limiting at 100 req/min per user",
        "Support for refresh tokens"
      ]
    }
  },
  "metadata": {
    "workflow_step": 2,
    "total_steps": 7,
    "context_references": ["project-spec-v1.2", "auth-requirements"],
    "retry_count": 0,
    "max_retries": 3
  }
}
```

##### **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—å®šç¾©**
```yaml
message_types:
  # ã‚¿ã‚¹ã‚¯ç®¡ç†
  task_assignment:
    description: "æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã®å‰²ã‚Šå½“ã¦"
    required_fields: ["task_id", "description", "deadline"]
    sender_types: ["ProductManager"]
    recipient_types: ["Engineer", "QA", "TechWriter"]
  
  task_acceptance:
    description: "ã‚¿ã‚¹ã‚¯ã®å—è«¾ç¢ºèª"
    required_fields: ["task_id", "estimated_completion"]
    sender_types: ["Engineer", "QA", "TechWriter"]
    recipient_types: ["ProductManager"]
  
  progress_update:
    description: "é€²æ—çŠ¶æ³ã®æ›´æ–°"
    required_fields: ["task_id", "progress_percentage", "status"]
    sender_types: ["Engineer", "QA", "TechWriter"]
    recipient_types: ["ProductManager"]
    frequency: "every_2_hours"
  
  # ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  code_review_request:
    description: "ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ä¾é ¼"
    required_fields: ["pr_url", "review_type", "priority"]
    sender_types: ["Engineer"]
    recipient_types: ["SeniorEngineer", "QA"]
  
  knowledge_sharing:
    description: "çŸ¥è­˜ãƒ»ç™ºè¦‹ã®å…±æœ‰"
    required_fields: ["topic", "content", "relevance"]
    sender_types: ["All"]
    recipient_types: ["All"]
  
  # ç·Šæ€¥æ™‚
  error_report:
    description: "ã‚¨ãƒ©ãƒ¼ãƒ»éšœå®³ã®å ±å‘Š"
    required_fields: ["error_type", "severity", "affected_systems"]
    sender_types: ["All"]
    recipient_types: ["ProductManager", "SeniorEngineer"]
    priority: "critical"
  
  escalation:
    description: "å•é¡Œã®ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"
    required_fields: ["issue_id", "escalation_reason", "required_action"]
    sender_types: ["All"]
    recipient_types: ["ProductManager"]
    priority: "high"
```

---

## ğŸ§  ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### ğŸ“Š éšå±¤å‹ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ 
```python
class ContextManager:
    def __init__(self):
        self.short_term_memory = ShortTermMemory(ttl=3600)  # 1æ™‚é–“
        self.working_memory = WorkingMemory(ttl=86400)      # 24æ™‚é–“
        self.long_term_memory = LongTermMemory()            # æ°¸ç¶šåŒ–
        self.shared_memory = SharedMemory()                 # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“å…±æœ‰
    
    async def store_context(self, agent_id: str, context: dict, memory_type: str):
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜"""
        
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ä¸
        context['timestamp'] = datetime.now()
        context['agent_id'] = agent_id
        
        if memory_type == "short_term":
            await self.short_term_memory.store(context)
        elif memory_type == "working":
            await self.working_memory.store(context)
        elif memory_type == "long_term":
            await self.long_term_memory.store(context)
        elif memory_type == "shared":
            await self.shared_memory.store(context)
            # ä»–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«é€šçŸ¥
            await self._notify_context_update(context)
    
    async def retrieve_context(self, agent_id: str, query: dict) -> list:
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢"""
        
        results = []
        
        # å„ãƒ¡ãƒ¢ãƒªã‹ã‚‰æ¤œç´¢
        for memory in [self.short_term_memory, self.working_memory, 
                      self.long_term_memory, self.shared_memory]:
            matches = await memory.search(query)
            results.extend(matches)
        
        # é–¢é€£æ€§ã§ã‚½ãƒ¼ãƒˆ
        sorted_results = self._rank_by_relevance(results, query)
        
        return sorted_results[:10]  # ä¸Šä½10ä»¶ã‚’è¿”ã™
```

#### ğŸ” ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢ã‚·ã‚¹ãƒ†ãƒ 
```python
class ContextSearchEngine:
    def __init__(self):
        self.vector_db = ChromaDB()
        self.keyword_index = ElasticSearch()
    
    async def semantic_search(self, query: str, agent_id: str) -> list:
        """ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯æ¤œç´¢"""
        
        # ã‚¯ã‚¨ãƒªã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–
        query_vector = await self._embed_query(query)
        
        # ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢å®Ÿè¡Œ
        similar_contexts = await self.vector_db.similarity_search(
            vector=query_vector,
            filter={"accessible_by": agent_id},
            limit=20
        )
        
        return similar_contexts
    
    async def keyword_search(self, keywords: list, agent_id: str) -> list:
        """ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢"""
        
        search_query = {
            "bool": {
                "must": [
                    {"terms": {"keywords": keywords}},
                    {"term": {"accessible_by": agent_id}}
                ]
            }
        }
        
        results = await self.keyword_index.search(
            index="agent_contexts",
            body={"query": search_query}
        )
        
        return results["hits"]["hits"]
    
    async def hybrid_search(self, query: str, keywords: list, agent_id: str) -> list:
        """ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ¤œç´¢"""
        
        # ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯æ¤œç´¢ã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ã‚’ä¸¦è¡Œå®Ÿè¡Œ
        semantic_results, keyword_results = await asyncio.gather(
            self.semantic_search(query, agent_id),
            self.keyword_search(keywords, agent_id)
        )
        
        # çµæœã‚’ãƒãƒ¼ã‚¸ã—ã¦ãƒ©ãƒ³ã‚­ãƒ³ã‚°
        merged_results = self._merge_and_rank(semantic_results, keyword_results)
        
        return merged_results
```

### ãƒ¡ãƒ¢ãƒªæˆ¦ç•¥

#### ğŸ—‚ï¸ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†é¡ã‚·ã‚¹ãƒ†ãƒ 
```yaml
context_categories:
  project_context:
    description: "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã«é–¢ã‚ã‚‹æ–‡è„ˆ"
    retention_period: "project_duration"
    sharing_scope: "all_agents"
    examples:
      - "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã¨è¦ä»¶"
      - "æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ±ºå®šç†ç”±"
      - "é‡è¦ãªè¨­è¨ˆæ±ºå®š"
  
  task_context:
    description: "ç‰¹å®šã‚¿ã‚¹ã‚¯ã«é–¢ã™ã‚‹æ–‡è„ˆ"
    retention_period: "task_completion + 30_days"
    sharing_scope: "task_participants"
    examples:
      - "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã®ç™ºè¦‹"
      - "æŠ€è¡“çš„èª²é¡Œã¨è§£æ±ºç­–"
      - "ãƒ†ã‚¹ãƒˆçµæœã¨å“è³ªæŒ‡æ¨™"
  
  knowledge_context:
    description: "å­¦ç¿’ãƒ»ç™ºè¦‹ã—ãŸçŸ¥è­˜"
    retention_period: "permanent"
    sharing_scope: "relevant_agents"
    examples:
      - "ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä½¿ç”¨æ–¹æ³•"
      - "ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æ‰‹æ³•"
      - "ãƒ‡ãƒãƒƒã‚°ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯"
  
  conversation_context:
    description: "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ä¼šè©±å±¥æ­´"
    retention_period: "7_days"
    sharing_scope: "conversation_participants"
    examples:
      - "éå»ã®è³ªå•ã¨å›ç­”"
      - "è­°è«–ã®æµã‚Œ"
      - "åˆæ„äº‹é …"
```

#### ğŸ”„ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°æˆ¦ç•¥
```python
class ContextUpdateManager:
    def __init__(self):
        self.update_strategies = {
            'project_context': ProjectContextUpdater(),
            'task_context': TaskContextUpdater(),
            'knowledge_context': KnowledgeContextUpdater(),
            'conversation_context': ConversationContextUpdater()
        }
    
    async def update_context(self, context_type: str, update_data: dict):
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°"""
        
        updater = self.update_strategies[context_type]
        
        # æ›´æ–°å‰ã®çŠ¶æ…‹ã‚’ä¿å­˜
        old_context = await self._get_current_context(context_type, update_data['id'])
        
        # æ›´æ–°å®Ÿè¡Œ
        new_context = await updater.update(update_data)
        
        # å¤‰æ›´ãƒ­ã‚°è¨˜éŒ²
        await self._log_context_change(old_context, new_context)
        
        # é–¢é€£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«é€šçŸ¥
        await self._notify_relevant_agents(context_type, new_context)
        
        return new_context
    
    async def _notify_relevant_agents(self, context_type: str, context: dict):
        """é–¢é€£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®é€šçŸ¥"""
        
        # é€šçŸ¥å¯¾è±¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç‰¹å®š
        relevant_agents = await self._find_relevant_agents(context_type, context)
        
        # ä¸¦è¡Œé€šçŸ¥
        notification_tasks = [
            self._send_context_update_notification(agent_id, context)
            for agent_id in relevant_agents
        ]
        
        await asyncio.gather(*notification_tasks)
```

---

## âš”ï¸ ç«¶åˆè§£æ±ºã‚·ã‚¹ãƒ†ãƒ 

### ç«¶åˆæ¤œå‡º

#### ğŸ” ç«¶åˆã‚·ãƒŠãƒªã‚ªå®šç¾©
```python
class ConflictDetector:
    def __init__(self):
        self.conflict_patterns = {
            'resource_conflict': ResourceConflictDetector(),
            'task_conflict': TaskConflictDetector(),
            'decision_conflict': DecisionConflictDetector(),
            'communication_conflict': CommunicationConflictDetector()
        }
    
    async def detect_conflicts(self, activity_stream: list) -> list:
        """ç«¶åˆæ¤œå‡º"""
        
        detected_conflicts = []
        
        for detector_type, detector in self.conflict_patterns.items():
            conflicts = await detector.scan(activity_stream)
            for conflict in conflicts:
                conflict['type'] = detector_type
                conflict['detected_at'] = datetime.now()
                detected_conflicts.append(conflict)
        
        return detected_conflicts

class ResourceConflictDetector:
    async def scan(self, activities: list) -> list:
        """ãƒªã‚½ãƒ¼ã‚¹ç«¶åˆæ¤œå‡º"""
        conflicts = []
        
        # åŒä¸€ãƒªã‚½ãƒ¼ã‚¹ã¸ã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹æ¤œå‡º
        resource_access = {}
        for activity in activities:
            if activity['type'] == 'resource_access':
                resource_id = activity['resource_id']
                if resource_id not in resource_access:
                    resource_access[resource_id] = []
                resource_access[resource_id].append(activity)
        
        # ç«¶åˆãƒã‚§ãƒƒã‚¯
        for resource_id, accesses in resource_access.items():
            if len(accesses) > 1:
                # æ™‚é–“é‡è¤‡ãƒã‚§ãƒƒã‚¯
                overlapping = self._find_time_overlaps(accesses)
                if overlapping:
                    conflicts.append({
                        'resource_id': resource_id,
                        'conflicting_agents': [a['agent_id'] for a in overlapping],
                        'conflict_time': overlapping[0]['start_time'],
                        'severity': 'medium'
                    })
        
        return conflicts
```

### ç«¶åˆè§£æ±ºæˆ¦ç•¥

#### âš–ï¸ éšå±¤å‹æ„æ€æ±ºå®šã‚·ã‚¹ãƒ†ãƒ 
```python
class ConflictResolver:
    def __init__(self):
        self.resolution_hierarchy = {
            'technical_decisions': 'senior-engineer-agent',
            'ux_decisions': 'frontend-agent', 
            'quality_standards': 'qa-agent',
            'project_priorities': 'pm-agent',
            'resource_allocation': 'pm-agent'
        }
        
        self.resolution_strategies = {
            'resource_conflict': ResourceConflictResolver(),
            'task_conflict': TaskConflictResolver(),
            'decision_conflict': DecisionConflictResolver()
        }
    
    async def resolve_conflict(self, conflict: dict) -> dict:
        """ç«¶åˆè§£æ±º"""
        
        conflict_type = conflict['type']
        resolver = self.resolution_strategies[conflict_type]
        
        # è§£æ±ºç­–ç”Ÿæˆ
        resolution_options = await resolver.generate_options(conflict)
        
        # æ„æ€æ±ºå®šè€…ç‰¹å®š
        decision_maker = self._get_decision_maker(conflict)
        
        # æ±ºå®šä¾é ¼
        resolution = await self._request_decision(
            decision_maker, 
            conflict, 
            resolution_options
        )
        
        # è§£æ±ºç­–å®Ÿè¡Œ
        result = await self._execute_resolution(resolution)
        
        # çµæœè¨˜éŒ²
        await self._log_resolution(conflict, resolution, result)
        
        return result
    
    def _get_decision_maker(self, conflict: dict) -> str:
        """æ„æ€æ±ºå®šè€…ç‰¹å®š"""
        
        # ç«¶åˆã‚«ãƒ†ã‚´ãƒªã«åŸºã¥ãåˆ¤å®š
        conflict_category = self._categorize_conflict(conflict)
        
        return self.resolution_hierarchy.get(
            conflict_category, 
            'pm-agent'  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        )
```

#### ğŸ—³ï¸ æŠ•ç¥¨ã‚·ã‚¹ãƒ†ãƒ 
```python
class VotingSystem:
    def __init__(self):
        self.voting_weights = {
            'pm-agent': 3.0,
            'senior-engineer-agent': 2.5,
            'frontend-agent': 2.0,
            'backend-agent': 2.0,
            'qa-agent': 2.0,
            'tech-writer-agent': 1.5
        }
    
    async def conduct_vote(self, issue: dict, eligible_voters: list) -> dict:
        """æŠ•ç¥¨å®Ÿæ–½"""
        
        # æŠ•ç¥¨é–‹å§‹é€šçŸ¥
        await self._notify_voting_start(issue, eligible_voters)
        
        # æŠ•ç¥¨æœŸé™è¨­å®šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼š1æ™‚é–“ï¼‰
        voting_deadline = datetime.now() + timedelta(hours=1)
        
        votes = []
        while datetime.now() < voting_deadline:
            # æŠ•ç¥¨åé›†
            new_votes = await self._collect_votes(issue['issue_id'])
            votes.extend(new_votes)
            
            # å…¨å“¡æŠ•ç¥¨å®Œäº†ãƒã‚§ãƒƒã‚¯
            if len(votes) >= len(eligible_voters):
                break
            
            await asyncio.sleep(60)  # 1åˆ†é–“éš”ã§ãƒã‚§ãƒƒã‚¯
        
        # çµæœé›†è¨ˆ
        result = await self._tally_votes(votes)
        
        # çµæœé€šçŸ¥
        await self._notify_voting_result(issue, result)
        
        return result
    
    async def _tally_votes(self, votes: list) -> dict:
        """æŠ•ç¥¨é›†è¨ˆ"""
        
        option_scores = {}
        total_weight = 0
        
        for vote in votes:
            agent_id = vote['agent_id']
            option = vote['option']
            weight = self.voting_weights.get(agent_id, 1.0)
            
            if option not in option_scores:
                option_scores[option] = 0
            
            option_scores[option] += weight
            total_weight += weight
        
        # ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸è¨ˆç®—
        percentages = {
            option: (score / total_weight) * 100
            for option, score in option_scores.items()
        }
        
        # å‹è€…æ±ºå®š
        winner = max(option_scores.keys(), key=lambda k: option_scores[k])
        
        return {
            'winner': winner,
            'scores': option_scores,
            'percentages': percentages,
            'total_participants': len(votes),
            'total_weight': total_weight
        }
```

---

## ğŸ› ãƒ‡ãƒãƒƒã‚°ãƒ»ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ´»å‹•å¯è¦–åŒ–

#### ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
```python
class AgentActivityDashboard:
    def __init__(self):
        self.websocket_server = WebSocketServer()
        self.activity_monitor = ActivityMonitor()
    
    async def start_monitoring(self):
        """ç›£è¦–é–‹å§‹"""
        
        # WebSocketã‚µãƒ¼ãƒãƒ¼èµ·å‹•
        await self.websocket_server.start(port=8080)
        
        # ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ç›£è¦–é–‹å§‹
        await self.activity_monitor.start_monitoring(
            callback=self._broadcast_activity_update
        )
    
    async def _broadcast_activity_update(self, activity: dict):
        """ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ›´æ–°ã®ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ"""
        
        # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿å¤‰æ›
        dashboard_data = {
            'timestamp': activity['timestamp'],
            'agent_id': activity['agent_id'],
            'activity_type': activity['type'],
            'status': activity['status'],
            'details': activity.get('details', {}),
            'performance_metrics': {
                'response_time': activity.get('response_time'),
                'memory_usage': activity.get('memory_usage'),
                'cpu_usage': activity.get('cpu_usage')
            }
        }
        
        # å…¨æ¥ç¶šã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡
        await self.websocket_server.broadcast(dashboard_data)
```

#### ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«
```python
class AgentDebugger:
    def __init__(self):
        self.conversation_logger = ConversationLogger()
        self.state_inspector = StateInspector()
        self.workflow_tracer = WorkflowTracer()
    
    async def debug_conversation(self, agent_id: str, conversation_id: str):
        """ä¼šè©±ãƒ‡ãƒãƒƒã‚°"""
        
        # ä¼šè©±å±¥æ­´å–å¾—
        conversation = await self.conversation_logger.get_conversation(
            conversation_id
        )
        
        # å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®åˆ†æ
        analysis = []
        for message in conversation['messages']:
            message_analysis = {
                'message_id': message['id'],
                'timestamp': message['timestamp'],
                'sender': message['sender'],
                'recipient': message['recipient'],
                'processing_time': message.get('processing_time'),
                'errors': message.get('errors', []),
                'context_used': message.get('context_references', []),
                'decisions_made': message.get('decisions', [])
            }
            analysis.append(message_analysis)
        
        return {
            'conversation_id': conversation_id,
            'total_messages': len(conversation['messages']),
            'duration': conversation['duration'],
            'participants': conversation['participants'],
            'message_analysis': analysis,
            'bottlenecks': self._identify_bottlenecks(analysis),
            'recommendations': self._generate_debug_recommendations(analysis)
        }
    
    async def inspect_agent_state(self, agent_id: str) -> dict:
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçŠ¶æ…‹æ¤œæŸ»"""
        
        state = await self.state_inspector.get_full_state(agent_id)
        
        return {
            'agent_id': agent_id,
            'current_tasks': state['active_tasks'],
            'memory_usage': state['memory'],
            'context_cache': state['context_cache'],
            'performance_metrics': state['metrics'],
            'recent_activities': state['recent_activities'],
            'error_log': state['errors'],
            'health_status': self._assess_agent_health(state)
        }
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

#### ğŸš¨ ã‚¨ãƒ©ãƒ¼åˆ†é¡ãƒ»å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ 
```python
class ErrorHandler:
    def __init__(self):
        self.error_classifiers = {
            'communication_error': CommunicationErrorHandler(),
            'context_error': ContextErrorHandler(), 
            'resource_error': ResourceErrorHandler(),
            'logic_error': LogicErrorHandler()
        }
        
        self.escalation_rules = {
            'critical': ['pm-agent', 'senior-engineer-agent'],
            'high': ['senior-engineer-agent'],
            'medium': ['originating-agent'],
            'low': ['log-only']
        }
    
    async def handle_error(self, error: dict) -> dict:
        """ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
        
        # ã‚¨ãƒ©ãƒ¼åˆ†é¡
        error_type = await self._classify_error(error)
        
        # é‡è¦åº¦è©•ä¾¡
        severity = await self._assess_severity(error)
        
        # é©åˆ‡ãªãƒãƒ³ãƒ‰ãƒ©ãƒ¼é¸æŠ
        handler = self.error_classifiers[error_type]
        
        # ã‚¨ãƒ©ãƒ¼å‡¦ç†å®Ÿè¡Œ
        resolution = await handler.handle(error)
        
        # ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¤å®š
        if severity in ['critical', 'high']:
            await self._escalate_error(error, severity)
        
        # ãƒ­ã‚°è¨˜éŒ²
        await self._log_error_handling(error, resolution)
        
        return resolution
    
    async def _escalate_error(self, error: dict, severity: str):
        """ã‚¨ãƒ©ãƒ¼ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        
        escalation_targets = self.escalation_rules[severity]
        
        escalation_message = {
            'type': 'error_escalation',
            'priority': 'critical',
            'content': {
                'error_id': error['id'],
                'error_type': error['type'],
                'severity': severity,
                'affected_systems': error['affected_systems'],
                'initial_handler': error['handler'],
                'resolution_attempted': error['resolution_attempted'],
                'additional_action_required': True
            }
        }
        
        # ä¸¦è¡Œã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        escalation_tasks = [
            self._send_escalation_message(target, escalation_message)
            for target in escalation_targets
        ]
        
        await asyncio.gather(*escalation_tasks)
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

#### ğŸ“ˆ ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã‚·ã‚¹ãƒ†ãƒ 
```python
class PerformanceMonitor:
    def __init__(self):
        self.metrics_collector = MetricsCollector()
        self.anomaly_detector = AnomalyDetector()
        self.alert_manager = AlertManager()
    
    async def collect_agent_metrics(self, agent_id: str) -> dict:
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†"""
        
        current_time = datetime.now()
        
        # åŸºæœ¬ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        basic_metrics = {
            'response_time': await self._measure_response_time(agent_id),
            'throughput': await self._measure_throughput(agent_id),
            'error_rate': await self._calculate_error_rate(agent_id),
            'memory_usage': await self._get_memory_usage(agent_id),
            'cpu_usage': await self._get_cpu_usage(agent_id)
        }
        
        # ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        comm_metrics = {
            'messages_sent': await self._count_messages_sent(agent_id),
            'messages_received': await self._count_messages_received(agent_id),
            'average_message_size': await self._avg_message_size(agent_id),
            'conversation_efficiency': await self._calc_conversation_efficiency(agent_id)
        }
        
        # ã‚¿ã‚¹ã‚¯ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        task_metrics = {
            'tasks_completed': await self._count_completed_tasks(agent_id),
            'tasks_in_progress': await self._count_active_tasks(agent_id),
            'average_task_duration': await self._avg_task_duration(agent_id),
            'task_success_rate': await self._calc_task_success_rate(agent_id)
        }
        
        all_metrics = {
            'agent_id': agent_id,
            'timestamp': current_time,
            'basic': basic_metrics,
            'communication': comm_metrics,
            'tasks': task_metrics
        }
        
        # ç•°å¸¸æ¤œçŸ¥
        anomalies = await self.anomaly_detector.detect(all_metrics)
        if anomalies:
            await self.alert_manager.send_anomaly_alert(agent_id, anomalies)
        
        # ãƒ¡ãƒˆãƒªã‚¯ã‚¹ä¿å­˜
        await self.metrics_collector.store(all_metrics)
        
        return all_metrics
```

---

## ğŸ”§ å®Ÿè£…ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ã‚¿ãƒ¼å®Ÿè£…

#### ğŸ“® ACPãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ã‚¿ãƒ¼
```python
class ACPMessageRouter:
    def __init__(self):
        self.agent_registry = AgentRegistry()
        self.message_queue = RedisMessageQueue()
        self.load_balancer = LoadBalancer()
        
    async def route_message(self, message: dict) -> dict:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
        
        try:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¤œè¨¼
            await self._validate_message(message)
            
            # å—ä¿¡è€…ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç‰¹å®š
            recipient = message['routing']['recipient']
            agent_instances = await self.agent_registry.find_agent_instances(
                recipient['agent_id']
            )
            
            if not agent_instances:
                raise AgentNotFoundError(f"Agent {recipient['agent_id']} not found")
            
            # ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°
            target_instance = await self.load_balancer.select_instance(
                agent_instances
            )
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡
            delivery_result = await self._deliver_message(target_instance, message)
            
            # é…ä¿¡ç¢ºèªè¦æ±‚ã®å ´åˆã¯ç¢ºèªå¾…ã¡
            if message['message'].get('requires_ack'):
                ack = await self._wait_for_acknowledgment(
                    message['header']['message_id'],
                    timeout=30
                )
                delivery_result['acknowledgment'] = ack
            
            return delivery_result
            
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
            await self._handle_routing_error(message, e)
            raise
    
    async def _deliver_message(self, target_instance: dict, message: dict) -> dict:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡"""
        
        delivery_start = datetime.now()
        
        try:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã«é€ä¿¡
            await self.message_queue.send(
                queue=target_instance['queue_name'],
                message=message
            )
            
            delivery_end = datetime.now()
            delivery_time = (delivery_end - delivery_start).total_seconds()
            
            return {
                'status': 'delivered',
                'delivery_time': delivery_time,
                'target_instance': target_instance['instance_id'],
                'timestamp': delivery_end
            }
            
        except Exception as e:
            return {
                'status': 'failed',
                'error': str(e),
                'timestamp': datetime.now()
            }
```

### ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰

#### âš™ï¸ ç’°å¢ƒè¨­å®š
```yaml
# docker-compose.yml for Agent Communication
version: '3.8'

services:
  acp-router:
    build: ./acp-router
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - POSTGRES_URL=postgresql://acp:password@postgres:5432/acp_db
    depends_on:
      - redis
      - postgres

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: acp_db
      POSTGRES_USER: acp
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql

  agent-monitor:
    build: ./monitoring
    ports:
      - "8080:8080"
    environment:
      - MONITOR_INTERVAL=30
      - ALERT_WEBHOOK_URL=${ALERT_WEBHOOK_URL}

volumes:
  redis_data:
  postgres_data:
```

#### ğŸ”Œ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆä¾‹
```python
# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè£…ä¾‹
class BaseAgent:
    def __init__(self, agent_id: str, agent_type: str):
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.message_handler = MessageHandler(self)
        self.context_manager = ContextManager()
        self.acp_client = ACPClient(agent_id)
    
    async def start(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–‹å§‹"""
        
        # ACPæ¥ç¶š
        await self.acp_client.connect()
        
        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†é–‹å§‹
        await self.message_handler.start_listening()
        
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæœŸåŒ–
        await self.context_manager.initialize()
        
        print(f"Agent {self.agent_id} started successfully")
    
    async def send_message(self, recipient_id: str, message_content: dict):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"""
        
        message = {
            'header': {
                'protocol_version': '2.0',
                'message_id': f"msg-{uuid.uuid4()}",
                'timestamp': datetime.now().isoformat(),
                'ttl': 3600
            },
            'routing': {
                'sender': {
                    'agent_id': self.agent_id,
                    'agent_type': self.agent_type
                },
                'recipient': {
                    'agent_id': recipient_id
                }
            },
            'message': message_content
        }
        
        return await self.acp_client.send_message(message)
    
    async def handle_incoming_message(self, message: dict):
        """å—ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†"""
        
        message_type = message['message']['type']
        
        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—åˆ¥å‡¦ç†
        if message_type == 'task_assignment':
            await self._handle_task_assignment(message)
        elif message_type == 'progress_request':
            await self._handle_progress_request(message)
        elif message_type == 'code_review_request':
            await self._handle_code_review_request(message)
        else:
            await self._handle_unknown_message(message)
```

---

## ğŸ“‹ é‹ç”¨ãƒ»ä¿å®ˆ

### å®šæœŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

#### ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
```python
class SystemHealthChecker:
    def __init__(self):
        self.health_checks = [
            MessageQueueHealthCheck(),
            DatabaseHealthCheck(),
            AgentConnectivityCheck(),
            PerformanceCheck()
        ]
    
    async def run_health_check(self) -> dict:
        """ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ"""
        
        results = {}
        overall_status = "healthy"
        
        for check in self.health_checks:
            try:
                result = await check.run()
                results[check.name] = result
                
                if result['status'] != 'healthy':
                    overall_status = "degraded"
                    
            except Exception as e:
                results[check.name] = {
                    'status': 'error',
                    'error': str(e)
                }
                overall_status = "unhealthy"
        
        return {
            'overall_status': overall_status,
            'timestamp': datetime.now(),
            'individual_checks': results,
            'recommendations': self._generate_recommendations(results)
        }
```

---

*ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä»•æ§˜æ›¸ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®æˆé•·ã¨é‹ç”¨çµŒé¨“ã«åŸºã¥ã„ã¦ç¶™ç¶šçš„ã«æ”¹å–„ã•ã‚Œã¾ã™ã€‚* 